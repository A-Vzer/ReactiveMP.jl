export ImportanceSamplingApproximation, ParallelImportanceSamplingApproximation

"""
    ImportanceSamplingApproximation

This structure stores all information needed to perform an importance sampling procedure and provides
convenient functions to generate samples and weights to approximate expectations

# Fields
- `rng`: random number generator objects
- `nsamples`: number of samples generated by default
"""
struct ImportanceSamplingApproximation{R}
    rng      :: R
    nsamples :: Int
end

getsamples(approximation::ImportanceSamplingApproximation, distribution)           = getsamples(approximation, distribution, approximation.nsamples)
getsamples(approximation::ImportanceSamplingApproximation, distribution, nsamples) = rand(approximation.rng, distribution, nsamples)

function approximate_meancov(approximation::ImportanceSamplingApproximation, g::Function, distribution)

    samples               = getsamples(approximation, distribution)
    transformed_samples   = g.(samples) 
    normalization         = sum(transformed_samples)
    weights               = transformed_samples ./ normalization
    
    m = mapreduce(r -> r[1] * r[2], +, zip(weights, samples))
    v = mapreduce(r -> r[1] * (r[2] - m) ^ 2, +, zip(weights, samples))

    return m, v
end

"""
    ParallelImportanceSamplingApproximation

This structure stores all information needed to perform an importance sampling procedure and provides
convenient functions to generate samples and weights to approximate expectations. Does approximation in parallel.

# Fields
- `rng`: random number generator objects
- `nsamples`: number of samples generated by default
"""
struct ParallelImportanceSamplingApproximation{R}
    rng      :: R
    nsamples :: Int
end

getsamples(approximation::ParallelImportanceSamplingApproximation, distribution)           = getsamples(approximation, distribution, approximation.nsamples)
getsamples(approximation::ParallelImportanceSamplingApproximation, distribution, nsamples) = rand(approximation.rng, distribution, nsamples)

using Distributed

function approximate_meancov(approximation::ParallelImportanceSamplingApproximation, g::Function, distribution)

    samples               = getsamples(approximation, distribution)
    transformed_samples   = pmap(g, samples)
    normalization         = sum(transformed_samples)

    _r = let normalization = normalization
        x -> x / normalization
    end

    weights               = pmap(_r, transformed_samples)

    m = @sync @distributed (+) for i = 1:length(samples)
        weights[i] * samples[i]
    end

    v = @sync @distributed (+) for i = 1:length(samples)
        weights[i] * (samples[i] - m) ^ 2
    end
    
    # m = mapreduce(r -> r[1] * r[2], +, zip(weights, samples))
    # v = mapreduce(r -> r[1] * (r[2] - m) ^ 2, +, zip(weights, samples))

    return m, v
end