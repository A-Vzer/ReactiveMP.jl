var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"ReactiveMP.jl is a Julia package for reactive message passing based Bayesian Inference on Factor Graphs. It supports both exact and variational inference.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"ReactiveMP.jl package is a successor of the ForneyLab.jl package. It follows the same ideas and concepts for message-passing based inference, but uses new reactive and efficient message passing implementation under the hood. The API between two packages is different due to a better flexibility, performance and new reactive approach for solving inference problems.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"This page provides the necessary information you need to get started with ReactiveMP.jl. We will show the general approach to solving inference problems with ReactiveMP.jl by means of a running example: inferring the bias of a coin.","category":"page"},{"location":"getting-started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Install ReactiveMP.jl through the Julia package manager:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"] add https://github.com/biaslab/ReactiveMP.jl","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"note: Note\nFor best user experience you also need to install GraphPPL.jl, Rocket.jll and Distributions.jl packages.","category":"page"},{"location":"getting-started/#Example:-Inferring-the-bias-of-a-coin","page":"Getting started","title":"Example: Inferring the bias of a coin","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The ReactiveMP.jl approach to solving inference problems consists of three phases:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Model specification: ReactiveMP.jl uses GraphPPL.jl package for model specification part. It offers a domain-specific language to specify your probabilistic model.\nInference specification: ReactiveMP.jl does not restrict any certain use-cases for inference specification part. It has been designed to be as flexible as possible, but for most of the model it consists of the same simple building blocks. In this example we will show one of the many possible ways to infer your quantities of interest.\nInference execution: Given model specification and inference procedure it is pretty straightforward to use reactive API from Rocket.jl to pass data to the inference backend and to run actual inference.","category":"page"},{"location":"getting-started/#Coin-flip-simulation","page":"Getting started","title":"Coin flip simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Let's start by creating some dataset. One approach could be flipping a coin N times and recording each outcome. Here, however, we will simulate this process reactively by sampling some values from a Bernoulli distribution infinitelly using Rocket.jl library. Each sample can be thought of as the outcome of single flip which is either heads or tails (1 or 0). We will assume that our virtual coin is biased, and lands heads up on 75% of the trials (on average).","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"using Rocket\nusing Distributions\n\nn = 50\np = 0.75\ndistribution = Bernoulli(p)\n\nstream = from(1:n) |> map(Int, (_) -> Int(rand(distribution)));","category":"page"},{"location":"extending/#Extending-the-functionality","page":"Extending","title":"Extending the functionality","text":"","category":"section"},{"location":"extending/#Adding-a-new-type-of-node","page":"Extending","title":"Adding a new type of node","text":"","category":"section"},{"location":"extending/","page":"Extending","title":"Extending","text":"ReactiveMP.jl package exports the @node macro to create a simple factor node with fixed number of arguments.","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"@node macro accepts three arguments:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"A functional form of the new node in form of a Julia type, e.g. Normal or typeof(+)\nA type of node: Stochastic or Deterministic\nA list of node arguments, e.g. [ out, mean, variance ]","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"note: Note\nBy convention a list of node arguments should start with out ","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"Examples:","category":"page"},{"location":"extending/","page":"Extending","title":"Extending","text":"@node GaussianMeanVariance Stochastic [ out, m, v ]\n@node typeof(+) Deterministic [ out, in1, in2 ]","category":"page"},{"location":"distributions/#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"ReactiveMP.jl library uses probability distributions types from Distributions.jl package. It also provides a wider range of possible parametrisations for some probability distributions, e.g NormalMeanPrecision or MvNormalMeanPrecision which might be more efficient in some situations.","category":"page"},{"location":"#ReactiveMP.jl-Documentation","page":"Home","title":"ReactiveMP.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for ReactiveMP.jl.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"getting-started.md\",\n  \"extending.md\",\n  \"distributions.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"api/node/#node_api","page":"Node","title":"Node API","text":"","category":"section"},{"location":"api/node/","page":"Node","title":"Node","text":"Deterministic\nStochastic\nisdeterministic\nisstochastic\nsdtype\nMeanField\nFullFactorisation\ncollect_factorisation\nNodeInterface\nIndexedNodeInterface\nname\ntag\nmessageout\nmessagein","category":"page"},{"location":"api/node/#ReactiveMP.Deterministic","page":"Node","title":"ReactiveMP.Deterministic","text":"Deterministic\n\nDeterministic object used to parametrize factor node object with determinstic type of relationship between variables.\n\nSee also: Stochastic, isdeterministic, isstochastic\n\n\n\n\n\n","category":"type"},{"location":"api/node/#ReactiveMP.Stochastic","page":"Node","title":"ReactiveMP.Stochastic","text":"Stochastic\n\nStochastic object used to parametrize factor node object with stochastic type of relationship between variables.\n\nSee also: Deterministic, isdeterministic, isstochastic\n\n\n\n\n\n","category":"type"},{"location":"api/node/#ReactiveMP.isdeterministic","page":"Node","title":"ReactiveMP.isdeterministic","text":"isdeterministic(node)\n\nFunction used to check if factor node object is deterministic or not. Returns true or false.\n\nSee also: Deterministic, Stochastic, isstochastic\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.isstochastic","page":"Node","title":"ReactiveMP.isstochastic","text":"isstochastic(node)\n\nFunction used to check if factor node object is stochastic or not. Returns true or false.\n\nSee also: Deterministic, Stochastic, isdeterministic\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.sdtype","page":"Node","title":"ReactiveMP.sdtype","text":"sdtype(object)\n\nReturns either Deterministic or Stochastic for a given object (if defined).\n\nSee also: Deterministic, Stochastic, isdeterministic, isstochastic\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.MeanField","page":"Node","title":"ReactiveMP.MeanField","text":"MeanField\n\nGeneric factorisation constraint used to specify a mean-field factorisation for recognition distribution q.\n\nSee also: FullFactorisation\n\n\n\n\n\n","category":"type"},{"location":"api/node/#ReactiveMP.FullFactorisation","page":"Node","title":"ReactiveMP.FullFactorisation","text":"FullFactorisation\n\nGeneric factorisation constraint used to specify a full factorisation for recognition distribution q.\n\nSee also: MeanField\n\n\n\n\n\n","category":"type"},{"location":"api/node/#ReactiveMP.collect_factorisation","page":"Node","title":"ReactiveMP.collect_factorisation","text":"collect_factorisation(nodetype, factorisation)\n\nThis function converts given factorisation to a correct internal factorisation representation for a given node. \n\nSee also: MeanField, FullFactorisation\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.NodeInterface","page":"Node","title":"ReactiveMP.NodeInterface","text":"NodeInterface\n\nNodeInterface object represents a single node-variable connection.\n\nSee also: name, tag, messageout, messagein\n\n\n\n\n\n","category":"type"},{"location":"api/node/#ReactiveMP.IndexedNodeInterface","page":"Node","title":"ReactiveMP.IndexedNodeInterface","text":"IndexedNodeInterface\n\nIndexedNodeInterface object represents a repetative node-variable connection.  Used in cases when node may connect different number of random variables with the same name, e.g. means and precisions of Gaussian Mixture node.\n\nSee also: name, tag, messageout, messagein\n\n\n\n\n\n","category":"type"},{"location":"api/node/#ReactiveMP.name","page":"Node","title":"ReactiveMP.name","text":"name(interface)\n\nReturns a name of the interface.\n\nSee also: NodeInterface, tag\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.tag","page":"Node","title":"ReactiveMP.tag","text":"tag(interface)\n\nReturns a tag of the interface in the form of Val{ name(interface) }.  The major difference between tag and name is that it is possible to dispath on interface's tag in message computation rule.\n\nSee also: NodeInterface, name\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.messageout","page":"Node","title":"ReactiveMP.messageout","text":"messageout(interface)\n\nReturns an outbound messages stream from the given interface.\n\nSee also: NodeInterface, messagein\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.messagein","page":"Node","title":"ReactiveMP.messagein","text":"messagein(interface)\n\nReturns an inbound messages stream from the given interface.\n\nSee also: NodeInterface, messageout\n\n\n\n\n\n","category":"function"},{"location":"api/node/","page":"Node","title":"Node","text":"Internal API","category":"page"},{"location":"api/node/","page":"Node","title":"Node","text":"ReactiveMP.connectvariable!\nReactiveMP.connectedvar\nReactiveMP.connectedvarindex\nReactiveMP.get_pipeline_stages\nReactiveMP.add_pipeline_stage!\nReactiveMP.FactorNodeLocalMarginal\nReactiveMP.FactorNodeLocalMarginals","category":"page"},{"location":"api/node/#ReactiveMP.connectvariable!","page":"Node","title":"ReactiveMP.connectvariable!","text":"connectvariable!(interface, variable, index)\n\nConnects a variable with the interface and given index. Index is used to distinguish this connection from others in case if variable is connected to multiple interfaces.\n\nSee also: NodeInterface, connectedvar, connectedvarindex\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.connectedvar","page":"Node","title":"ReactiveMP.connectedvar","text":"connectedvar(interface)\n\nReturns connected variable for the interface.\n\nSee also: NodeInterface, connectvariable!, connectedvarindex\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.connectedvarindex","page":"Node","title":"ReactiveMP.connectedvarindex","text":"connectedvarindex(interface)\n\nReturns an index of connected variable for the interface.\n\nSee also: NodeInterface, connectvariable!, connectedvar\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.get_pipeline_stages","page":"Node","title":"ReactiveMP.get_pipeline_stages","text":"get_pipeline_stages(interface)\n\nReturns an instance of pipeline stages of connected variable for the given interface\n\nSee also: NodeInterface, connectvariable!, connectedvar, add_inbound_pipeline_stage!\n\n\n\n\n\n","category":"function"},{"location":"api/node/#ReactiveMP.FactorNodeLocalMarginal","page":"Node","title":"ReactiveMP.FactorNodeLocalMarginal","text":"FactorNodeLocalMarginal\n\nThis object represents local marginals for some specific factor node.  Local marginal can be joint in case of structured factorisation.  Local to factor node marginal also can be shared with a corresponding marginal of some random variable.\n\nSee also: FactorNodeLocalMarginals\n\n\n\n\n\n","category":"type"},{"location":"api/node/#ReactiveMP.FactorNodeLocalMarginals","page":"Node","title":"ReactiveMP.FactorNodeLocalMarginals","text":"FactorNodeLocalMarginals\n\nThis object acts as an iterable and indexable proxy for local marginals for some node. \n\n\n\n\n\n","category":"type"}]
}
